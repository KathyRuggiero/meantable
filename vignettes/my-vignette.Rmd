---
title: "meantable: Exploring, summarising and visualising data from experiments"
author: "Katya Ruggiero"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    toc: true
    keep_md: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

#TOC {
  position: fixed;
  left: 0;
  top: 0;
  width: 250px;
  height: 100%;
  overflow:auto;
  font-size:14px;
  line-height: 600px;
}
body {
  max-width: 820px;
  margin: auto;
  margin-left:250px;
  line-height: 20px;
  font-size:16px;
}
</style>

```{r set-options, echo=FALSE}
options(width = 110)
```

Notes to myself: 

* Need to run `devtools::build_vignettes()` 
* Don't need to melt predicted means `ftable`. SO change examples in documentation to `as.data.frame()` and check
* in `confintplot`, add something to change the size of the circle of the mean difference
* in `getLSDsummary()` fix "2\times n columns" in Details of documentation. also consider changing this function's name to `lsdSummary()`

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(kableExtra)
library(captioner)
library(stringr)

# functions for generating figure numbers
f.ref <- function(x) {
  stringr::str_extract(figure_nums(x), "[^:]*")
}
figure_nums <- captioner::captioner(prefix = "Figure")

# functions for generating table numbers
t.ref <- function(x) {
  stringr::str_extract(table_nums(x), "[^:]*")
}

table_nums <- captioner::captioner(prefix = "Table")

# table captions
tab.flydata <- table_nums(name = "flydata", 
        caption = "First few rows of fruitfly dataframe.")
tab.flyGrpMedians <- table_nums(name = "flyGrpMedians", 
        caption = "Median longevity and interquartile ranges (IQR) calculated by number and type of
        partner using <tt>groupSummaries()</tt>.")
tab.flyGrpMeans <- table_nums(name = "flyGrpMeans", 
        caption = "Mean longevity, standard errors of means (SEs) and variances (Var) calculated by
        number and type of partner using <tt>groupSummaries()</tt>.")
tab.flyReps <- table_nums(name = "flyReps", 
        caption = "Replication of Control factor and of each feasible combination of Partners and
        Type.")
tab.flyANOVA <- table_nums(name = "flyANOVA", 
        caption = "ANOVA resulting from linear model, defined by <tt>fruitfly.lm</tt>, fitted to
        Longevity data.")
tab.flyPMoutput <- table_nums(name = "flyPMoutput", 
        caption = "Summary of contents of the list of objects generated by applying the 
        <tt>predictmeans()</tt> function to the linear model term <tt>Control:Partners:Type</tt>.")
tab.flyMeansSEMs <- table_nums(name = "flyMeansSEMs", 
        caption = "Predicted mean longevity, and standard error (s.e.), for the Control factor and
        for each combination of number and <tt>Type</tt> of female <tt>Partners</tt>.")
tab.flyPostHocSummary <- table_nums(name = "flyPostHocSummary", 
        caption = "Summary of post-hoc test results generated by applying the
        <tt>makeSummaryTable()</tt> function to the list created by the <tt>predictmeans()</tt>
        function.")
tab.flyInterestingComp <- table_nums(name = "flyInterestingComp", 
        caption = "Summary of post-hoc test results restricted to *interesting* pairwise
        comparisons.")

# figure captions
fig.flybplots <- figure_nums(name = "flybplots", 
                        caption = "Boxplots of male fruitfly longevity by the supplied number and 
                        type of partner.")
fig.flybpEmbel <- figure_nums(name = "flybpEmbel", 
                        caption = "Boxplots of male fruitfly longevity embellished with informative
                        x- and y-axis labels.")
fig.flyCIplotBase <- figure_nums(name = "flyCIplotBase", 
                        caption = "Confidence interval plot, with the filled circles and error bars
                        corresponding to the <tt>Difference</tt> between pairs of means and their 
                        95% confidence intervals respectively.")
fig.flyCIplotByFactor <- figure_nums(name = "flyCIplotByFactor", 
                        caption = "Confidence interval plot using `Control` factor as a column facetting variable.")
fig.flyCIplotByPval <- figure_nums(name = "flyCIplotByPval", 
                        caption = "Confidence interval plot using `Control` factor as a column facetting variable, with open circles
                        (filled circles) indicating t-tests which yielded p-values less than (greater than; ns) the nominal 0.05 level of
                        significance.")

#library("dlstats")

#x <- cran_stats("designGLMM")
#x <- cran_stats("infoDecompuTE")
#head(x)
#sum(x$downloads)
#mean(x$downloads)
```

## Introduction

The `meantable` package is designed for applied statisticians and researchers who use R to analyse data from designed experiments. It comprises a suite of functions which facilitate data exploration, summarisation and visualisation. Specifically, it significantly reduces the subtantial coding effort required to generate tabular and graphical summaries of post-hoc test results. Further, the functions were developeded with a view to generating tables that require minimal post-production editing and publication-quality graphics for inclusion in researchers' manuscripts. The net result is a package which enables researchers to focus their efforts on the task of interpreting the inferences which can be drawn from their analyses and, therefore, on writing their manuscripts.

Designed experiments are largely used for conducting comparative studies of two or more experimental conditions (i.e. treatments, or treatment combinations in the case of multi-factor experiments). A goal in the analysis of many such studies is to conduct post-hoc tests of pairwise comparisons of treatment means of the dependent variable (i.e. the measured response). The `meantable` package was developed to complement the [predictmeans](https://cran.r-project.org/package=predictmeans) package containing the `predictmeans()` function used to perform these post-hoc tests, extracting these results and summarising them in clear and meaningful ways.

The data visualisation functions in `meantable` are wrappers to Hadley Wickham's  [ggplot2](https://cran.r-project.org/package=ggplot2) data visualisation package, enabling production of elegant publication-quality graphs. This benefits those who do not wish to invest time in the initially steep learning curve required to master  [ggplot2](https://cran.r-project.org/package=ggplot2) (see [Why I don't use ggplot2](https://simplystatistics.org/2016/02/11/why-i-dont-use-ggplot2/) by Jeff Leak of [Simply Statistics](https://simplystatistics.org/)), but does not disadvantage those who wish to have greater control over the graphs `meantab` produces because of the grammar of graphics tool on which [ggplot2](https://cran.r-project.org/package=ggplot2) is based. 

The current version of `meantable` has been developed primarily with a focus on experiments in which the measured response can suitably be analysed using *linear* (mixed) models, i.e. using the `anova()` and `lm()` functions, available in base R, and the `lme()` and `lmer()` functions, available within the [nlme](https://cran.r-project.org/package=nlme) and [lme4](https://cran.r-project.org/package=lme4) packages respectively. `meantable` is also suitable for linear mixed models fitted using the `asreml()` function in the `ASReml-R` package (the engine for using the numerical routines from the ASReml$^\textsf{TM}$ program; Gilmour *et al.*, 2002). In this case users should use the ` predictparallel.asreml()` function contained in the complementary [asremlPlus](https://cran.r-project.org/package=asremlPlus) package to perform post-hoc tests.
    
<!-- Performing post-hoc tests for pairwise comparisons of means and presenting summaries of the results in a clear and meaningful way are important objectives in the analysis of data from (designed) experiments. Until the introduction of the `predictmeans` package, post-hoc tests were one of the things that R did least well. This is because the default parameterisation used by the linear model fitting functions in R is the *first-level zero constraint*, also known as the *reference cell model* among some R users. The parameter estimates under this constraint are not, in general, the pairwise comparisons of means that are of primary interest. Extracting the pairwise comparisons of interest is relatively straightforward, albeit tedious, for simple experiments with, say, a single treatment factor. However, for more complex experiments with multiple treatment factors and which additionally involve blocking, this process is more involved. 

Enter the `predictmeans` function: it conducts the post-hoc tests for all pairwise comparisons of means for any fitted term in a linear (mixed) model, and more (see the `predictmeans` documentation for more information). The one drawback of `predictmeans` is that the results, stored in a <tt>list</tt>, are spread across three objects: the means are stored in an <tt>ftable</tt>, the pairwise differences between means an corresponding least significant differences in a <tt>matrix</tt> and $t$-statistics and \eqn{p}-values in another <tt>matrix</tt>. `meantable` contains a suite of wrapper functions which extract information from across these three objects and assembles them in a single summary table of post-hoc test results. 

But wait, there's more! Not all pairwise comparisons are of interest, so  `meantable` contains functions which enable the user to easily extract only those comparisons which are of interest. `meantable` also contains functions which generate plots of predicted means with least significant difference (LSD) bars which are specific to the pairwise comparisons of interest or, if the user prefers, pairwise differences between means with $100 \times (1-\alpha)\%$ confidence interval error bars. `meantable` also contains a few other wrapper functions which simplify the task of exploring data from multi-factor experiments. 

What now follows is a guided tour of the functions contained in `meantable`, with examples showing their use.

We now demonstrate the workflow of using the `meantable` functions through the analysis of two datasets, `fruitfly` and `bugs`, both available in the package.-->

## What is in this vignette?

This vignette navigates the `meantable` workflow, from exploring data via boxplots and summary statistics through to generating post-hoc test summary tables and graphs. The focus is on demonstrating function utility, not model fitting, via the analysis of two datasets, namely [fruitfly](#fruitfly-data) and [bugs](#bugs-data). Both are available in this package. 


```{r, echo=FALSE, message=FALSE}
library(meantable)
```

##  Longevity of the male fruitfly
<a name="fruitfly-data"></a>

*Does increased sexual activity affect longevity of male fruitflies?* In an attempt to answer this question, Partridge & Farquhar (1981) conducted an experiment in which sexual activity was manipulated by supplying individual male fruitflies with either one (<tt>Partners = 1</tt>) or eight (<tt>Partners = 8</tt>) receptive virgin females (<tt>Type = 1</tt>) per day. The longevity of these males was compared with that of two control types. The first control consisted of individual males kept with either one or eight newly inseminated (pregnant) nonreceptive females (<tt>Type = 0</tt>). The other control was individual males kept with no females (<tt>Partners = 0</tt>; <tt>Type = 9</tt>). Twenty-five male fruitflies were randomly assigned to each of these four groups. The observations on each fly were `Longevity` (lifespan, in days), `Thorax` length (measured in mm), and `Sleep` (the percentage of each day spent sleeping). The first few rows of the `fruitfly` data, shown in `r t.ref("flydata")`, are made available in the current R session, via the `data()` function, i.e.

```{r}
data(fruitfly)
```
 
```{r echo=FALSE}
knitr::kable(head(fruitfly), caption=tab.flydata, align="cccccc", 
             format="html")
```

### Converting variables to factors

A common feature of datasets from designed experiments is that often most, if not all, of the indepedent variables have  categorical values. Frequently the categories are coded as integers. So, if the data are read into R without any other "intervention" such variables will be designated the type <tt>integer</tt>. This will be the case for the variables `ID` (containing values <tt>1</tt> -- <tt>25</tt>),  `Partners` (<tt>0</tt>, <tt>1</tt> and <tt>8</tt>) and `Type` (<tt>0 = newly pregnant</tt>, <tt>1 = virgin</tt> and <tt>9 = not applicable</tt>). Thus, before we can begin exploring any connection between these variables and the longevity of male fruitflies in any meaningful way, we must first convert them to type <tt>factor</tt>. We can perform this type conversion of all three variables simultaneously using `meantable`'s <tt>toFactor()</tt> function, i.e.

```{r}
newfruitfly <- toFactor(fruitfly, variables = c("ID", "Partners", "Type"))
```

Try using `str(fruiftly)` before and after apply the `toFactor()` function to the data to check that this has had the desired effect.

<br>
<br>

The [fruitfly](#fruitfly-data) data contains three measured variables, namely `Longevity` (lifespan, in days), `Thorax` (length of thorax, in mm) and `Sleep` (percentage of each day spent sleeping). We will first explore the nature of the association between between `Thorax` length and `Longevity` for each combination of `Partners` and `Type`. We will subsequently examine whether `Thorax` length also plays a role in explaining `Longevity`. 

Although the values of `Partners` are measureable quantities, i.e. their relative magnitudes have a meaningful order, there are only three values considered in the experiment and so we have elected to treat this variable as a factor all subsequent analyses. This is also how Partridge and Farquhar (1981) treated this variable.

### Exploring longevity by partner type and number

__*Boxplots by treatment combination*__

An important underlying assumption of linear models is that the data are drawn from populations with homogeneous variances. Boxplots provide an informative visualisation tool for this purpose. It is clear from the boxplots of `Longevity` by treatment groups, here `Partners` and `Type`, shown in `r f.ref("flybplots")` that the homogeneity of variance assumption is satisfied by these data.  This plot was generated by the `ggBoxplot` wrapper function (code shown below), which takes the `fruitfly` dataframe as its first argument. The next two arguments (`y` and `x`) tell `ggBoxplot` which variables to plot on the vertical (`y`) and horizontal (`x`) axes respectively. The final argument, `facets`, is used to tell `ggBoxplot` to partition the plot into three side-by-side panels according to the three `Type`s of partners with which the male fruitflies were supplied. The `facets` argument takes as its value a character vector of exactly length 2. Notice that in this case `Type` is presented as the first character string, resulting in the panels being printed across the page. The second character string is simply `"."`. If the order of these two character strings reversed, the panels would have been printed vertically down the page. It will be shown later, using the  [bugs](#bugs-data), how a two-way array of panels may be generated using the `facets` argument.

```{r, fig.show='hide'}
ggBoxplot(newfruitfly, y = "Longevity", x = "Partners", facets = c("Type", "."))
```

<br>

```{r, echo=FALSE, fig.height=4.5, fig.width=8, fig.align='center', fig.cap = fig.flybplots}
ggBoxplot(newfruitfly, y = "Longevity", x = "Partners", facets = c("Type", "."))
```

<br><br>
The boxplots in `r f.ref("flybplots")` would be easier to read if the integer codes currently used for different partner `Type`s were given more meaningful labels. The `transform()` function in base R may be used to do this, i.e.

```{r}
newfruitfly <- transform(newfruitfly, Type = factor(Type, levels=c(9,0,1),
  labels=c("Control", "Newly pregnant", "Virgin")))
```

And, of course, more informative axis labels are also desirable. The x- and y-axis labels are controlled via the `xLabel` and `yLabel` arguments, respectively, i.e.

```{r, fig.show='hide'}
ggBoxplot(newfruitfly, y = "Longevity", x = "Partners", facets = c("Type", "."),
         xLabel = "Number of partners", yLabel = "Lifespan (days)")
```

<br>

The final plot, with all embellishments, is shown in `r f.ref("flybpEmbel")`.

<br>

```{r, fig.height=4.5, fig.width=8, fig.align='center', echo=FALSE, fig.cap=fig.flybpEmbel}
ggBoxplot(newfruitfly, y = "Longevity", x = "Partners", facets = c("Type", "."),
         xLabel = "Number of partners", yLabel = "Lifespan (days)")
```

<br><br>

So what do the boxplots show? Bottom line: having a harem of virgin female fruitflies may not be an optimal strategy for a male fruitfly who wants to maximise his lifespan! 

<br>

__*Summary statistics by treatment combination*__

Summary statistics by `Type` and number of `Partners` may be calculated using the `groupSummaries()`, a `tapply()` wrapper function, which enables anonymous functions to be passed to it. For example, we may be interested in calculating the medians and iterquartile ranges in the boxplots shown in `r f.ref("flybpEmbel")`. To do this, we again supply the `fruitfly` dataframe to the first argument of this function, the name of the dependent variable to `y` and the names of the two treatment factors by which we want the statistics calculated to `factors`. The anonymous function is supplied to the `FUN` argument, i.e.


```{r results='hide'}
groupSummaries(newfruitfly, y="Longevity", factors=c("Type", "Partners"), 
               FUN=function(x) c(Median=median(x), IQR=IQR(x)))
``` 

The resulting dataframe is shown in `r t.ref("flyGrpMedians")`.

```{r echo=FALSE}
knitr::kable(groupSummaries(newfruitfly, y="Longevity", factors=c("Type", "Partners"), 
             FUN=function(x) c(Median=median(x), IQR=IQR(x))), 
             caption=tab.flyGrpMedians, align="lccc", digits=2, 
             format="html", table.attr = "style='width:50%;'")
```

Alternatively, we might be interested in the means, their standard erors and, perhaps, also the variances of each group, i.e.

```{r results='hide'}
groupSummaries(newfruitfly, y="Longevity", factors=c("Type", "Partners"), 
               FUN=function(x) c(meanse(x), Var=var(x)))
```

Note that the `meanse()` function, contained in the anonymous function supplied to `FUN`, computes the means and standard erros of means and is included in the suite of `meantable` functions. The resulting dataframe is shown in `r t.ref("flyGrpMeans")`.

```{r echo=FALSE}
knitr::kable(groupSummaries(newfruitfly, y="Longevity", factors=c("Type", "Partners"), 
             FUN=function(x) c(meanse(x), Var=var(x))), 
             caption=tab.flyGrpMeans, align="lcccc", 
             format="html", table.attr = "style='width:60%;'", digits=2)
```

The IQRs in `r t.ref("flyGrpMedians")` and variances in `r t.ref("flyGrpMeans")` show that the variation in longevity among `Control` male fruitflies is almost twice that among male fruitflies living with 8 virgin females! So, not only is longevity lower, on average, among male fruitflies saupplied with a harem of virgin females, but the variability in this shorter average lifespan is also lower. 

Given that `groupSummaries()` summaries is simply a wrapper for `tapply()`, is their any advantage in using the former? Yes, because it returns the results in a dataframe (rather than the multi-dimensional array returned by `tapply()`), a form which makes it a amenable for further processing by other R functions.

<!--
KR change this and reference [boxplot.stats()](https://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/boxplot.stats.html): The two ‘hinges’ are versions of the first and third quartile, i.e., close to quantile(x, c(1,3)/4). The hinges equal the quartiles for odd n (where n <- length(x)) and differ for even n. Whereas the quartiles only equal observations for n %% 4 == 1 (n = 1 mod 4), the hinges do so additionally for n %% 4 == 2 (n = 2 mod 4), and are in the middle of two observations otherwise. -->

```{r, include=FALSE}
fivenum.df <- groupSummaries(newfruitfly, y="Longevity", factors=c("Type", "Partners"), fivenum)
names(fivenum.df)[-(1:2)] <- c("Min", "Hinge1", "Median", "Hinge2", "Max")
fivenum.df
```

### Tables of predicted means and their standard errors

__*Linear model for factorial plus added control*__

The fruitfly experiment is a $2 \times 2$ factorial experiment with an added control. The control represents a "zero" level for both the `Type` and `Partners` factors, while the factorial structure of Type $\times$ Partners operates only when a male fruitfly is supplied with at least one female fruitfly (virgin or newly pregnant). `r t.ref("flyReps")` shows the combinations of `Partners` and `Type` that are feasible. It also shows that an additional `Control` factor, populated with value (level) <tt>No</tt> when a female is supplied and <tt>Yes</tt> otherwise.

```{r, echo=FALSE, results='asis'}
library(kableExtra)
repsTable <- knitr::kable(with(newfruitfly, table(Type, Partners)), "html",
                          caption = tab.flyReps, table.attr = "style='width:35%;'")
add_header_above(repsTable, c("", "Partners" = 3))
```

The fixed effects model for this factorial plus added control requires both crossing and nesting, i.e. `Control/(Partners*Type)`, as shown below. The resulting ANOVA for this fitted model is shown in `r t.ref("flyANOVA")`.

```{r}
# create Control factor
newfruitfly$Control <- factor(ifelse(newfruitfly$Type=="Control", "Yes", "No"))
fruitfly.lm <- lm(Longevity ~ Control/(Partners*Type), data=newfruitfly)
```

<br>

```{r, echo=FALSE, results='asis'}
options(knitr.kable.NA = '')
knitr::kable(anova(fruitfly.lm), "html", caption = tab.flyANOVA)
```

<br>

The following table summarises the interpretation of each term in the ANOVA (`r t.ref("flyANOVA")`). Using this we see that the presence of female fruitflies has a significant on longevity (p = 0.023) and that, when females are supplied, there is an interaction between the number and type of partner (p = 0.006).

<br>


| Term                  | Interpretation                                                 |
|:--------------------- |:-------------------------------------------------------------- |
| Control               | overall effect of the presence of female fruitflies            |
| Control:Partners      | comparison between 1 and 8 female partners (averaged over the  |
|                       | different virgin and newly pregnant partners)                  |
| Control:Type          | comparison between virgin and newly pregnant female partners   |
|                       | (averaged over the number of partners)                         |
| Control:Partners:Type | the interaction between Partners and Type (given that a female |
|                       | has been supplied)                                             |


<br>

__*Predicted Longevity*__

Now that we have fitted the linear model, we use the `predictmeans()` function from the [predictmeans](https://cran.r-project.org/package=predictmeans) package to calculate the predicted means, and their standard errors, for each available treatment combination shown in `r t.ref("flyReps")`. To do this, we must supply the `modelterm` argument which the term in the fitted model which includes all three factors, namely <tt>Control:Partners:Type</tt>, i.e.

<a name="fruitfly-pm"></a>
```{r}
fruitfly.pm <- predictmeans(fruitfly.lm, modelterm = "Control:Partners:Type", 
                            pairwise = TRUE, plot = FALSE)
```

So that the `predictmeans()` function also performs the post-hoc t-tests, we must supply it with the argument `pairwise = TRUE` (default `FALSE`). The contents of the resulting object is a <tt>list</tt> comprising the 6 objects of different classes, as summarised in `r t.ref("flyPMoutput")`.

<a name="pmListContents-table"></a>
```{r echo=FALSE, results='asis'}
fflypmClass.mat <- do.call('rbind', lapply(fruitfly.pm, class))
fflypmClass.df <- data.frame(Object=rownames(fflypmClass.mat), Class=fflypmClass.mat[,1])
knitr::kable(fflypmClass.df, row.names=FALSE, align="lc", caption = tab.flyPMoutput, 
             format="html", table.attr = "style='width:50%;'")
```

For presentation purposes, such as in a peer-reviewed journal article, we may wish to tabulate the predicted means together with their standard errors. The predicted means from the fitted model fitted to the `fruitfly` data are stored in a flat table (i.e. object of class `ftable`), i.e.

```{r}
fruitfly.pm$`Predicted Means`
```

The `NA`s in the above table appear in those cells for which the treatment combinations were unfeasible. As each treatment combination was equally replicated (i.e. 25 male fruitflies per group), the standard errors of the means are all equal, i.e.

```{r}
fruitfly.pm$`Standard Error of Means`
```

The `means2df()` function aggregates this information in a single dataframe, as shown in `r t.ref("flyMeansSEMs")`. This function takes the <tt>list</tt> generated by the `predictmeans()` function as its first argument and, optionally, the number of significant `digits`, here 2, may also be specified, i.e.

```{r}
fruitfly.mse <- means2df(fruitfly.pm, digits = 2)
```

<br>

```{r echo=FALSE, results='asis'}
knitr::kable(fruitfly.mse, align='cccrr', row.names = FALSE, caption = tab.flyMeansSEMs, 
             format="html", table.attr = "style='width:50%;'")
```

The predicted means contained in the `fruitfly.mse` dataframe we will be required later when generating visual summaries of the post-hoc test results. The standard errors of the means (SEMs) are not required for these plots and, since in this case the SEMs are all equal, we may choose to drop this column from the dataframe. This information may be recorded elsewhere, for example, in a  relevant table caption. To exclude the `s.e.` column from the dataframe, simply provide the extra argument `se = FALSE` to the `means2df()` function. 

<a name="block-inflated-sem"></a>While SEMs may be interesting for completely randomised designs, this is not true in general. The estimated SEMs from experiments involving blocking factors and in which these block factor have non-negligible random effects will result in inflated SEMs. A more appropriate statistic to use is the effective standard error (see GenStat manual - reference). This will be implemented in future version of `meantable`.

### Summarising post-hoc test results

From our analyses so far (i.e. boxplots, ANOVA and predicted means), it appears that the optimal strategy for a male fruitfly wishing to maximimise his longevity is a life of celibacy! Is this true? Is there a statistically significant difference in mean longevity between male fruitflies supplied with a single newly pregnant female and those supplied with a single virgin female? If so, what is the magnitude and direction of this difference? What do the post-hoc test results say? 

The information required to answer these questions is contained across two matrices generated by `predictmeans()`, namely the `Pairwise LSDs` matrix, where all pairwise differences between means are recorded in the upper triangle of the matrix while their corresponding LSDs are recorded in the lower triangle, as printed below. Notice that the matrix has three attributes: the <tt>Significance level</tt> and <tt>Degrees of freedom</tt>, which are used to determine the critical value of the t-statistic which itself is used to compute the LSDs (Least Significant Differences), and the <tt>Note</tt>, which describes how to interpret the contents of the matrix. 

```{r}
fruitfly.pm$"Pairwise LSDs"
```

<br>

The `Pairwise p-value` matrix, printed below, contains the corresponding t-statistics (upper triangle) and p-values (lower triangle).

```{r}
fruitfly.pm$"Pairwise p-value"
```

<br>

For a small experiment such as this, reading the contents of the two matrices is easy. However,  larger experiments (i.e. more factors and/or factors comprising more than just a couple of levels each) yield much larger matrices, making the task of extracting the relevant results a much more laborious and time-consuming task. We will see this later when we encounter the bugs [KR: Add LINK to bugs] data. The `makeSummaryTable()` function was developed to automate this task, collating and storing the relevant information in a single dataframe, i.e. 

```{r}
fruitfly.tab <- makeSummaryTable(fruitfly.pm)
```

`r t.ref("flyPostHocSummary")` shows the contents of the dataframe created by the `makeSummaryTables()` function. Each row is a summary of the post-hoc test results associated with a given pairwise comparison of means. The first entry in each row, the `Comparison`, contains a character string with the names of the two treatment groups whose means are contrasted, separated by a minus sign. For example, the `Comparison` in the first row of the table is between the predicted mean `Longevity` of fruitflies in the `Yes:0:Control` group minuse the predicted mean `Longevity` of those in the `No:1:Newly pregnant` group. Since the `Difference` between these predicted means is -1.24, the `Comparison` name tells us that male fruitflies in this study who were supplied with a newly pregnant female lived, on average, about a day longer than celebate males. This difference is not statistically significant (p = 0.7677).  

```{r echo=FALSE, results='asis'}
knitr::kable(makeSummaryTable(fruitfly.pm), row.names = FALSE, cap=tab.flyPostHocSummary,
             format="html")
```

In addition to extracting and collating the information available from the list of objects generated by `predictmeans()`, the `makeSummaryTable()` also computes, for each pairwise difference between means, the standard error of the difference (`SED`) and the lower (`lwr`) and upper (`upr`) confidence limits of each difference. Note that the level of significance used to determine the LSD and, therefore, confidence limits in the summary table above is set within the `predictmeans()` function. The argument therein used to control the level of significance is `level`. Here the default `level = 0.05` was used.

<br>

__*Not all comparisons are "interesting"*__

Not all of the pairwise comparisons in `r t.ref("flyPostHocSummary")` are of biological interest. For instance, the comparison of longevity between male fruitflies supplied with 1 *newly pregnant* female and those supplied with 8 *virgin* females, while statistically significant (p < 0.0001), begs the question: "What is the cause of this difference in longevity?" It may be the number of females, or their pregnancy status, or both. In this case, we may not be interested in this contrast. More generally, we may only be interested in presenting results from those pairwise comparisons of treatment groups that differ in the levels of one, and the same, factor across the pair of treatments. 

The fruitfly experiment is an unusual case due to the "added control" factor. So, we are interested in keeping all pairwise comparisons between the control group and the four factorial treatment combinations of `Partners` and `Types`. However, among the pairwise comparisons between the four factorial treatment combinations of `Partners` and `Type` we are only interested in retaining comparisons between groups that differ in the levels of only one factor. We can do this by applying the `getFixedLevelComparisons()` function to the `Comparison` names in the last six rows of the table, i.e.

```{r}
# select comparisons that do not include the control treatment
noControlComparisons <- fruitfly.tab$Comparison[5:10]

# find rows with "interesting" comparisons
keepRows <- getFixedLevelComparisons(noControlComparisons, sepChar = ":")

# keep only those rows with "interesting" comparisons
fruitfly.tab2 <- rbind(fruitfly.tab[1:4, ], fruitfly.tab[5:10,][keepRows,])

# store the comparison names for later use
fruitflyCompNames <- fruitfly.tab2$Comparison

# simplify comparison names
fruitfly.tab2$Comparison <- gsub("(Yes:0:)|No:", "", fruitfly.tab2$Comparison)
```

Ordinarily, extracting the "interesting" comparisons is straightforward, requiring two lines of code. It is complicated here by the unusual "added control" in the fruitfly experiment. The resulting dataframe is shown in `r t.ref("flyInterestingComp")`.

```{r echo=FALSE, results='asis'}
knitr::kable(fruitfly.tab2, row.names = FALSE, cap=tab.flyInterestingComp,
             format="html")
```

The post-hoc tests tells us about the average lifespan of male fruitflies supplied with 8 virgin females? It is significantly reduced, by an average of almost 25 days, compared with celibate males. While celibacy appears to extend life significantly, it seems that a monogamous lifestyle, living with a single virgin female, may provide a compromise since the mean decrease in lifespan is about 7 days (compared with celibacy)! 

<br>

### Visual summaries of post-hoc test results

One way we may visually summarise the contents of `r t.ref("flyInterestingComp")` is to plot each `Difference` with its corresponding 95% lower (`lwr`) and upper (`upr`) confidence limits, as shown in the confidence interval plot in `r f.ref("flyCIplotBase")` which was generated using the `confintplot()` function, i.e.

```{r, fig.height=6, fig.width=8, fig.align='center', fig.show='hide'}
confintplot(fruitfly.tab2, y="Difference", x = "Comparison",
            axisLabelSize = 16, tickMarkLabelSize = 12, xTickLabelAngle = 90)
```

The `confintplot()` function takes the `fruitfly.tab2` dataframe as its first argument. As with `ggBoxplot()`, it also has arguments `y` and `x` for nominating which variables will be drawn on the vertical and horizontal axes respectively. Additional arguments give the user further control over plots appearance. Here, for example, `axisLabelSize` is used to control the font size of the x- and y-axis labels, `tickMarkLabelSize` is used to control the font size of the tick mark labels, and `xTickLabelAngle` is used to control the angle of the tick mark labels with respect to the x-axis. Currently only three angles are possible: 0 (parallel with the x-axis), 45 (at a 45 degree angle) and 90 (perpendicular to the x-axis). Confidence intervals which do not cross the dashed horizontal line indicate pairwise differences which are significantly different to one another (here at the 0.05 level). This dashed line may be suppressed by supplying `confintplot()` with the argument `zeroline = FALSE` (default `TRUE`). 

<br>

```{r, echo=FALSE, fig.height=6, fig.width=8, fig.align='center', fig.cap=fig.flyCIplotBase}
confintplot(fruitfly.tab2, y="Difference", x = "Comparison", yLabel = "Difference (days)",
            axisLabelSize = 16, tickMarkLabelSize = 12, xTickLabelAngle = 90)
```
<br><br>


__*Making post-hoc test summary tables more amenable to further processing*__

<tt>Comparison</tt> names written in the form <tt>treatment1--treatment2</tt> (e.g. see `r f.ref("flyCIplotBase")`) have the advantage of clarity with respect to the order of subtraction between a pair of treatment group means. A drawback of this format, however, is that it is not particularly amenable to sorting or subsetting by specific factor levels. It also severely restricts control over how the results may be plotted. For instance, rather than the layout in `r f.ref("flyCIplotBase")`, we may prefer to have a plot which clearly separates contrasts involving the `Control` group, consisting of "Celibate" male fruitflies, and "Active" males supplied with `Newly pregrant` or `Virgin` females, as shown in `r f.ref("flyCIplotByFactor")`. 

<br>

```{r echo=FALSE}
disaggNames.df <- comparisonNames2df(fruitflyCompNames, split.at = ":",
                                     varNames = c("Control", "Partners", "Type"))
fruitfly.tab2 <- data.frame(Control=disaggNames.df[,1], fruitfly.tab2)
fruitfly.tab2 <- transform(fruitfly.tab2, 
                 Control = factor(Control, levels=c("Yes", "No"), labels=c("Celibate", "Active")))
fruitfly.tab2$Comparison <- factor(fruitfly.tab2$Comparison)
```

```{r, echo=FALSE, fig.height=6, fig.width=8, fig.align='center', fig.cap=fig.flyCIplotByFactor}
confintplot(fruitfly.tab2, y="Difference", x = "Comparison", facets = c("Control", "."),
            axisLabelSize = 16, tickMarkLabelSize = 12, xTickLabelAngle = 90)
```

<br>

To generate the plot shown in `r f.ref("flyCIplotByFactor")` we must first disaggregate the comparison names into their original factor-level names. This task is performed by the  `comparisonNames2df()` function which operates on a character vector of comparison names. To illustrate, consider the reduced set of comparison names we earlier stored in `fruitflyCompNames`, i.e.

```{r}
fruitflyCompNames
```

We want to *split* these comparison names at the colon (:)
```{r}
disaggNames.df <- comparisonNames2df(fruitflyCompNames, split.at = ":",
                                     varNames = c("Control", "Partners", "Type"))
```

It returns a dataframe comprising $2n$ columns, where $n$ is the number of factors in the `modelterm` argument supplied to `predictmeans()`. In the case of the fruitfly data, the value supplied to the `modelterm` argument was `"Control:Partners:Type"` ([see code](#fruitfly-pm) used to calculate predicted means). 

```{r}
head(disaggNames.df)
```


We insert a copy of the `Control1` factor (first column in the above table) into the `fruitfly.tab2` dataframe, so that we may use it as a facet variable in our plot. Before generating the plot, however, we will relabel the `Yes` and `No` values of `Control1` with `Celebate` and `Active` respectively.


```{r}
disaggNames.df <- comparisonNames2df(fruitflyCompNames, split.at = ":",
                                     varNames = c("Control", "Partners", "Type"))
```
```{r}
fruitfly.tab2 <- data.frame(Control=disaggNames.df[,1], fruitfly.tab2)
fruitfly.tab2 <- transform(fruitfly.tab2, 
                 Control = factor(Control, levels=c("Yes", "No"), labels=c("Celibate", "Active")))
```
```{r echo=FALSE, results='asis'}
knitr::kable(fruitfly.tab2, row.names = FALSE)
```

We can now use the `Control` factor to lay out the plot in two-column grid according to celibate and active male fruitflies, i.e.

```{r, fig.show='hide'}
fruitfly.tab2$Comparison <- factor(fruitfly.tab2$Comparison)
confintplot(fruitfly.tab2, y="Difference", x = "Comparison", facets = c("Control", "."),
            axisLabelSize = 16, tickMarkLabelSize = 12, xTickLabelAngle = 90)
```



<br>

As we would expect, the results in the above confidence interval plot agree with those in the previous table; confidence intervals which do not cross <tt>Difference = 0</tt> dashed line indicate a significant difference between the means at 0.05 level. Specifically, we see that longevity is significantly higher for male fruitflies who are celibate, supplied with 1 virgin female or 8 newly pregnant females than it is for those supplied with a harem of 8 virgin females. The nice thing about this plot is that we can also so when there is a tendency for increased longevity, even if not statistically significant. For example, we are 95% confident that the mean lifespan of male fruitflies supplied with a newly pregnant female is -0.25 to 16.3 days longer those supplied with a virgin female.

Finally, we may choose to distinguish between those pairwise differences between means that have a $p$-value less than a nominal level of significance, `alpha`, and those which do not. We do this by providing additional arguments to `confintplot`, namely we set `showSignif = TRUE` (to use different plotting characters for `Difference`s which are statistically significant), `pvalVar = "p"` (to nominate the column in the dataframe containing the $p$-values) and `alpha = 0.05`, i.e. `r f.ref("flyCIplotByPval")`

```{r, fig.show='hide'}
confintplot(fruitfly.tab2, y="Difference", x = "Comparison", facets = c("Control", "."),
            showSignif=TRUE, pvalVar="p", alpha = 0.05,
            axisLabelSize = 16, tickMarkLabelSize = 12, xTickLabelAngle = 90)
```

<br>

```{r, echo=FALSE, fig.height=6, fig.width=8, fig.align='center',fig.cap=fig.flyCIplotByPval}
confintplot(fruitfly.tab2, y="Difference", x = "Comparison", facets = c("Control", "."),
            showSignif=TRUE, pvalVar="p", alpha = 0.05,
            axisLabelSize = 16, tickMarkLabelSize = 12, xTickLabelAngle = 90)
```


<br>

__*Plots with Least Significant Difference error bars*__

<br>

Some researchers prefer to plot means with standard error bars as visual summaries for post-hoc tests. It is not uncommon among experimental biologists, for example, to use bar plots with the tops of the bars representing the raw means and with error bars drawn emerging from the top (and sometimes also the bottom) of each bar, e.g. 

[Put image from journal article]

It is almost ubiquitous for such error bars to be the length of a single standard error of the mean (SEM), each calculated directly from the raw data (rather than using model-based SEM which is used to perform post-hoc tests). Equally ubiquitous are the pairs of bars connected by horizontal lines drawn above them, accompanied one or more asterisks indicating the strength of evidence for statistical significance. If the purpose of such plots is to present a visual summary of a set of post-hoc test results, then there are at least three cases which may be made against the use $\pm 1 \times$ raw SEM error bars as a visual yardstick for assessing statistically significant differences between pairs of means:

1. This is equivalent to constructing (approximately) a 67% CI for each mean. The temptation is to then interpret two non-overlapping CIs as meaning that the corresponding pair of means are significantly different. This interpretation is not unreasonable, but may be unsatisfactory since the actual level of significance for a single pairwise comparison is 0.165 (rather than often preferred 0.05 level).
2. Post-hoc tests use a linear model-based estimate of the SEM, which is effectively calculated by weighted average of the treatment group variances because linear models assume *homogeneity* of variance. So, shouldn't model-based estimates of SEMs be used rather than raw SEMs?
3. Raw SEMs are inappropriate in the presence of known sources of systematic random variation (i.e. experiments which include blocking and in which the block factors are fitted as random effects). As [previously](#block-inflated-sem) discussed, when non-negligible these sources of variation lead to inflated SEMs.

So, what is a more suitable quantity for error bars when the objective of a plot is to provide a visual summary of post-hoc test results? The *least significant difference*, i.e. the value that the absolute size of the difference between a pair of means must exceed in order for them to be considered statistically significant for at a nominal level of significance, $\alpha$, defined as

\begin{equation*}
  \textrm{LSD} = t_{\textrm{df}, 1-\alpha/2} \times \textrm{SED}, 
\end{equation*}

where the <tt>SED</tt> denotes the standard error of the difference betweeen a pair of means estimated with  <tt>df</tt>  residual degrees of freedom in the fitted model.

We use `meantable`'s `meansLSDplot()` function to generate such a plot for the post-hoc tests on the `fruitfly` data. To do this, we first use the `makeLSDlist()` function to generate the requisite information for `meansLSDplot()`, i.e.

```{r}
fruitfly.list <- makeLSDlist(meansData = fruitfly.mse, y = "Mean", x = "Type", LSD = 8.293, 
                             edgeWidth = 0.05)
```

The first argument takes `fruitfly.mse` dataframe which contains the predicted means, plus a column for each model term factor for which we have predicted means, namely `Partners`, `Control` and `Type`. The dataframe contains one row for each unique combination of the levels of these factors. We also need to declare the variables in `fruitfly.m2df` we wish to be plotted on the `x` and `y` axes, and the value of the `LSD` which we know from the post-hoc tests summary table above to be 9.293. The `edgeWidth` argument is used to control the width of the horizontal lines drawn at the top and bottom of the LSD bar. The contents of the returned <tt>list</tt> are as follows.

```{r echo=FALSE}
fruitfly.list
```

The following table contains a description of the contents of each object in the above list. 

| Object name | Contents                                                       |
|:------------|:-------------------------------------------------------------- |
| meansData   | Original dataframe supplied to `makeLSDlist()` containing information on means to be plotted|
| xBreaks     | Co-ordinates of x-axis at which to place tickmarks and tickmark labels        |
| xLabels     | Tickmark labels                                                               |
| xLimits     | Limits of the x-axis                                                          |
| barData     | x and y co-ordinates of the LSD bar                                           |
| edgeData    | x and y co-ordinates of the horizontal lines to be drawn at the bottom and top of the LSD bar|

We now supply the contents of `fruitfly.list` to the `meansLSDplot()` function, again providing the  names the variables we want plotted on the x- and y-axes, i.e.

```{r, fig.height=4.5, fig.width=8, fig.align='center'}
meansLSDplot(lsdList =fruitfly.list, x = "Type", y = "Mean", 
             xLabel = "Type of partner", yLabel = "Predicted mean")
```
<br>

The problem with the above plot is that the same plotting character is used for both the means of 1 and 8 female fruitflies across both the `Newly pregnant` and `Virgin` females categories. So, let's use the `colour` argument to tell `meansLSDplot()` to colour by number of `Partners`.

```{r, fig.height=4.5, fig.width=8, fig.align='center'}
meansLSDplot(lsdList =fruitfly.list, x = "Type", y = "Mean",
             xLabel = "Type of partner", yLabel = "Predicted mean",
             colour = "Partners")
```
<br>

Of course, most journals prefer figures to be drawn in black and white, in which case we replace the `colour` argument with the `shape` argument. While we are at it, we will increase the size of the plotting characters with the `pointSize` argument.

```{r, fig.height=4.5, fig.width=8, fig.align='center'}
meansLSDplot(lsdList =fruitfly.list, x = "Type", y = "Mean",
             xLabel = "Type of partner", yLabel = "Predicted mean",
             shape = "Partners", pointSize = 3.5)
```
<br>

Although arguably excessive, we may wish to distinguish the number of partners by both the colour and shape of the plotting characters.


```{r, fig.height=4.5, fig.width=8, fig.align='center'}
meansLSDplot(lsdList =fruitfly.list, x = "Type", y = "Mean",
             xLabel = "Type of partner", yLabel = "Predicted mean",
             colour = "Partners", shape = "Partners", pointSize = 3.5)
```
<br>

Finally, we may wish to the join points corresponding to the same number of partners with lines, e.g.

```{r, fig.height=4.5, fig.width=8, fig.align='center'}
meansLSDplot(lsdList =fruitfly.list, x = "Type", y = "Mean",
             xLabel = "Type of partner", yLabel = "Predicted mean",
             shape = "Partners", pointSize = 3.5, lineType = "Partners")
```

<br>

So how do we interpret the above plot? Simple: any pair of means which a further apart than the LSD bar are considered statistically significant at the 0.05 level.  A quick cross check against the confidence interval plot we generated earlier and with the post-hoc tests summary table will show that our conclusions here agree with what we found earlier.

Notice that the bottom of the LSD bar in the above plots is that the bottom of the bar coincides with smallest mean in the plot. It will be shown later that there is some flexiblity in the starting position of the LSD bar. However, currently there is no option to have the top of the bar start at the largest mean in the plot. This would have been convenient here in terms of making it easier to judge whether the vertical distance between the two triangles (Newly pregnant versus Virgin when a single female is supplied) exceeds the LSD. This option will be implemented in a future version of this package.

### Thorax length and longevity?

The [fruitfly](#fruitfly-data) data contains three measured variables, namely `Longevity` (lifespan, in days), `Thorax` (length of thorax, in mm) and `Sleep` (percentage of each day spent sleeping). Here we will only explore the nature of the association between between thorax length and longevity for each combination of number of `Partner`s and partner `Type`. Although the values of `Partner` are numeric, only three values -- 0, 1 and 8 -- are considered in the experiment. So it is not unreasonable that we treat this variable as a factor with three levels, which is what we do in our treatment of this dataset and, indeed, how Partridge and Farquhar (1981) treated this variable.


### Summary statistics by treatment groups



```{r, fig.height=8, fig.width=8, echo=FALSE, include=FALSE}
fruitfly1 <- droplevels(newfruitfly[newfruitfly$Type!=9,])
pairs(fruitfly1[, c("Longevity", "Thorax", "Sleep")], oma=c(7,5,5,5),
      pch=21, cex=1.5,bg=c("blue", "green3")[fruitfly1$Type])
par(xpd=NA)
legend(x=0.29, y=0.05, legend=c("newly pregnant female", "virgin female"),
       ncol=2, pt.bg=c("blue", "green3"), pch=21, bty="n")
fruitfly1$logSleep <- log(fruitfly1$Sleep)
pairs(fruitfly1[, c("Longevity", "Thorax", "logSleep")], oma=c(7,5,5,5),
      pch=21, cex=1.5,bg=c("blue", "green3")[fruitfly1$Type])
par(xpd=NA)
legend(x=0.29, y=0.05, legend=c("newly pregnant female", "virgin female"),
       ncol=2, pt.bg=c("blue", "green3"), pch=21, bty="n")
```

```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
ggplot(transform(newfruitfly, 
                 Partners = factor(Partners, labels=c("No partners", "1 partner", "8 partners"))), 
       aes(y=Longevity, x=Thorax, colour=Type)) +
  geom_point(size=2) +
  xlab("Thorax (mm)") +
  ylab("Lifespan (days)") +
  facet_grid(.~Partners) +
  #geom_smooth(method = "lm") + 
  geom_smooth(method="loess", span=0.95) +
  scale_colour_manual(values=c("blue", "red", "green3")) +
  theme_bw() +
  theme(strip.text.x = element_text(size = 14),
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))
```

```{r}
groupCor(fruitfly, measure.vars=c("Longevity", "Thorax"), factors=c("Type"))
```

```{r}
groupCor(fruitfly, measure.vars=c("Longevity", "Thorax", "Sleep"), factors=c("Partners", "Type"))
```

```{r}
ffthorax.lm0 <- lm(Longevity ~ (Control/(Partners*Type))*Thorax, data=newfruitfly)
anova(ffthorax.lm0)

ffthorax.lm1 <- lm(Longevity ~ (Control/(Partners*Type)) + Thorax, data=newfruitfly)
anova(ffthorax.lm0, ffthorax.lm1)
anova(ffthorax.lm1)

ffthorax.pm <- predictmeans(ffthorax.lm1, modelterm = "Control:Partners:Type",
                            pairwise = TRUE, plot = FALSE)
ffthorax.tab <- makeSummaryTable(ffthorax.pm)
ffthorax.tab2 <- rbind(ffthorax.tab[1:4, ], ffthorax.tab[5:10,][keepRows,])
ffthorax.tab2$Comparison <- gsub("(Yes:0:)|No:", "", ffthorax.tab2$Comparison)
ffthorax.tab2 <- data.frame(Control=disaggNames.df[,1], ffthorax.tab2)
ffthorax.tab2 <- transform(ffthorax.tab2, 
                 Control = factor(Control, levels=c("Yes", "No"), labels=c("Celibate", "Active")))
```

```{r echo=FALSE, results='asis'}
knitr::kable(ffthorax.tab2, row.names = FALSE)
```

Confidence interval plots. The LSD is now 5.914.

```{r}
ffthorax.tab2$Comparison <- factor(ffthorax.tab2$Comparison)
ffthorax.mse <- means2df(ffthorax.pm)
ffthorax.list <- makeLSDlist(meansData = ffthorax.mse, y = "Mean", x = "Type", 
                             LSD = mean(ffthorax.tab2$LSD), 
                             edgeWidth = 0.05)
```


```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
meansLSDplot(lsdList =ffthorax.list, x = "Type", y = "Mean",
             xLabel = "Type of partner", yLabel = "Predicted mean",
             shape = "Partners", pointSize = 3.5, lineType = "Partners")
```


## How some bugs grow in a biofluid
<a name="bugs-data"></a>

The goal of this study was to assess the growth of five bacterial strains (E. coli, E. faecalis, K. pneumoniae, P. aeruginosa and S. aureus) over time (4 and 24 hours post-inoculation) in mesenteric lymph harvested from normal (Control) and diseased (DM, HS and AP) rats. Growth of these bacterial strains was investigated under two settings, namely at Low and High initial (baseline) inoculation concentrations. The `bugs` data available in the `meantable` package includes only the data collected from the low baseline concentration setting.

Describe contents of `bugs`

```{r}
data(bugs)
```
```{r, echo=FALSE, results='asis'}
knitr::kable(head(bugs))
```

[Perhaps use these sentences in the actual analysis/demonstrations below:] Since fair comparisons between disease models, both within and across time, depend on homogeneous baseline concentrations of each strain, baseline concentrations are first explored and analysed and then followed by a discussion of the results from the analyses of the baseline-adjusted data.


Describe the dataset.

```{r}
data(bugs)
```

```{r results='asis'}
knitr::kable(head(bugs), row.names = FALSE, align='r')
```

### Exploring the data

```{r fig.height=5, fig.width=8, fig.align='center'}
bugs$logBaseline <- log10(bugs$Baseline + 1)
ggBoxplot(bugs, x="State", y="logBaseline", xLabel = "Disease state", 
          yLabel = "Baseline log10(Concentration)", facets=c("Bacteria", "."),
          axisLabelSize=18, tickMarkLabelSize = 12, xStripTextSize = 12,
          xTickLabelAngle = 90)
```

### Weighted least squares analysis

A *weighted* least squares (WLS) two-way ANOVA was used to analyse the effects of disease State and Bacterial strain on baseline $log_{10}$(Concentration). As expected, there is no effect of State as the data were collected pre-inoculation of the bacteria into lymph samples. However, the interaction between State and Bacteria highly significant (p < 0.0001), indicating that the magnitude of the difference in mean baseline $log_{10}$(Concentration) between pairs of disease states depends on bacterial strain. (Note that WLS was used to take account of the heterogeneous variances among State-Bacteria treatment combinations.) 

The following table shows the predicted mean log-concentrations, and their standard errors, for each combination of disease state and bacterial strain. 

```{r echo=FALSE}
# add weight column to d1 
# note: denominator n-1 is used by var(), giving an unbiased estimator
#       of the variance for i.i.d observations
var.mat <- with(bugs, tapply(logBaseline, list(State, Bacteria), var))
var.df <- melt(var.mat)
names(var.df) <- c("State", "Bacteria", "Var")
newbugs <- merge(bugs, var.df)
newbugs$Weight <- 1/newbugs$Var

# WLS two-way anova
baselineBugs.lm <- lm(logBaseline ~ State*Bacteria, data = newbugs, weights = Weight)
anova(baselineBugs.lm)
```

### Predicted means

Make some comment about all of the SEMs being different from one another, in contrast to what we saw in the fruitfly example.

```{r echo=FALSE}
baselineBugs.pm <- predictmeans(baselineBugs.lm, modelterm = "State:Bacteria", pairwise=TRUE, 
                                plot = FALSE)
bugs.m2df <- means2df(baselineBugs.pm, digit = 2)
bugs.m2df

#mlowBaselineWt.pm <- melt(lowBaselineWt.pm$"Predicted Means")
#names(mlowBaselineWt.pm) <- gsub("^(value.)", "", names(mlowBaselineWt.pm))
#loMeanSEM.df <- data.frame(mlowBaselineWt.pm, SEM=c(lowBaselineWt.pm$"Standard Error of Means"))
#with(loMeanSEM.df, loMeanSEM.df[order(Bacteria, State),])
```

```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
ggplot(mapping = aes(x = State, y = Mean)) +
  geom_point(data = bugs.m2df) +
  facet_grid(.~Bacteria) +
  theme_bw()
```


### Summary table of post-hoc tests

We now generate the summary table of post-hoc test results, i.e. all pairwise comparisons of means. Notice that there are 190 row in this table. However, many of these pairwise comparisons are not of interest. For instance, row 2 contains the results of the comparison between the means of `Control:E. coli` and `AP:E. faecalis`. Neither disease states nor bacterial strains are the same between these two treatment groups, so what is the clinical meaning of the results of this contrast?

```{r}
baselineBugs.tab <- makeSummaryTable(baselineBugs.pm)
dim(baselineBugs.tab)
```

```{r echo=FALSE, results='asis'}
knitr::kable(baselineBugs.tab[1:10,], row.names = FALSE)
```

```{r}
# min, max and average LSD from predictmeans()
c(baselineBugs.pm$LSD)
```


We use the `getFixedLevelComparisons()` function to identifies those `Comparison` names in which the pair of factorial treatment combinations differ only in the levels of one of the treatment factors. This reduces the table from 190 to 70 rows.

```{r}
keepRows <- getFixedLevelComparisons(baselineBugs.tab[,1], sepChar = ":")
baselineBugs.tab2 <- baselineBugs.tab[keepRows,]
dim(baselineBugs.tab2)
```

```{r echo=FALSE, results='asis'}
knitr::kable(baselineBugs.tab2[1:10,], row.names = FALSE)
```


```{r}
# min, max and average LSD from predictmeans()
with(baselineBugs.tab2, c(Max.LSD=max(LSD), Min.LSD=min(LSD), Mean=mean(LSD)))
```

How do we now plot the results of 70 pairwise differences? This is a case where plotting the differences with 95% CI error bars is not going to work well. An alternative is to plot the predicted means with LSD bars. While `predictmeans()` does offer a plotting option to do this, only the average LSD bar is plotted on the graph. The is unsuitable for cases such as this where the LSD may differ by an order of magnitude between different treatment combinations. 

So, what do we need to do this? We need to first disaggregate the `Comparison` names,  i.e.

```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
names.df <- comparisonNames2df(baselineBugs.tab2$Comparison, split.at = ":", 
                               varNames = c("Disease", "Bacteria"))
baselineBugs.tab3 <- data.frame(names.df, baselineBugs.tab2[,-1])
dim(baselineBugs.tab3)
head(baselineBugs.tab3)
avgLSD.baseBugs3 <- mean(baselineBugs.tab3$LSD) # avg LSD = 0.298

baseBugs3a.list <- makeLSDlist(meansData = bugs.m2df, y = "Mean", x = "State",
                               LSD = avgLSD.baseBugs3, eqLevelFactors = "Bacteria",
                               lsdVar = "LSD_avg", edgeWidth = 0.1)
meansLSDplot(lsdList = baseBugs3a.list, x = "State", y = "Mean", facets = c("Bacteria","."),
             xLabel = "Disease state", yLabel = "log10(Cell count)",
             tickMarkLabelSize = 11, xTickLabelAngle = 90)


baseBugs3b.lsd <- getLSDsummary(baselineBugs.tab3, lsdVar="LSD", by = "Bacteria1")
baseBugs3b.lsd$LSD_avg <- avgLSD.baseBugs3
baseBugs3b.list <- makeLSDlist(meansData = bugs.m2df, y = "Mean", x = "State",
                               LSD = baseBugs3b.lsd, eqLevelFactors = "Bacteria",
                               lsdVar = "LSD_avg", edgeWidth = 0.1)
meansLSDplot(lsdList = baseBugs3b.list, x = "State", y = "Mean", facets = c("Bacteria","."),
             xLabel = "Disease state", yLabel = "log10(Cell count)",
             tickMarkLabelSize = 11, xTickLabelAngle = 90)


dim(baselineBugs.tab3)
baseBugs3c.lsd <- getLSDsummary(baselineBugs.tab3, lsdVar="LSD", by = "Bacteria1")
baseBugs3c.lsd
baseBugs3c.list <- makeLSDlist(meansData = bugs.m2df, y = "Mean", x = "State",
                              LSD = baseBugs3c.lsd, eqLevelFactors = "Bacteria",
                              lsdVar = "LSD_avg", edgeWidth = 0.1)
meansLSDplot(lsdList = baseBugs3c.list, x = "State", y = "Mean", facets = c("Bacteria","."),
             xLabel = "Disease state", yLabel = "log10(Cell count)",
             tickMarkLabelSize = 11, xTickLabelAngle = 90)
```

```{r}
with(baselineBugs.tab2, c(Max.LSD=max(LSD), Min.LSD=min(LSD), Mean=mean(LSD)))
```

There are two ways I can plot this data:

1. With Disease state on the x-axis, separated by Bacteria, or
2. With Bacteria on the x-axis, separated by Disease state.

`meantable` makes this straightforward, with the `whichComparison()` function. I want to make pairwise comparisons between Disease states within Bacterial strains. To do this, I set `factor = "Disease"` to indicate I am interested in only those pairwise comparisons in which the levels of `Disease1` and `Disease2` differ from one another.

```{r}
keepRows <- whichComparison(names.df, contrFactor = "Disease")
baselineBugs.tab4 <- baselineBugs.tab3[keepRows,]
dim(baselineBugs.tab4)
```

```{r echo=FALSE, results='asis'}
knitr::kable(baselineBugs.tab4, row.names = FALSE)
```

```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
baseBugs4.lsd <- getLSDsummary(baselineBugs.tab4, lsdVar="LSD", by = "Bacteria1")
baseBugs4.lsd
baseBugs4.list <- makeLSDlist(meansData = bugs.m2df, y = "Mean", x = "State",
                              LSD = baseBugs4.lsd, eqLevelFactors = "Bacteria",
                              lsdVar = "LSD_avg", edgeWidth = 0.1)
meansLSDplot(lsdList = baseBugs4.list, x = "State", y = "Mean", facets = c("Bacteria","."),
             xLabel = "Disease state", yLabel = "log10(Cell count)",
             tickMarkLabelSize = 11, xTickLabelAngle = 90)
```

Since the panels will be by Bacterial strain, and we will plot only one LSD bar per panel, let's examine the LSDs by Bacterial strain. What do we notice about the LSDs? 

```{r echo=FALSE, results='asis'}
knitr::kable(baselineBugs.tab4, row.names = FALSE)
```

An alternative is to use confidence interval plots. We can easily set this up. 

```{r}
baselineBugs.tab5 <- baselineBugs.tab4[,-4][,c(2,1,3:10)]
baselineBugs.tab6 <- with(baselineBugs.tab5, 
                          data.frame(Bacteria=Bacteria1, 
                                     Comparison=paste0(Disease1,"-",Disease2),
                                     baselineBugs.tab5[,-(1:3)]))
baselineBugs.tab6 <- with(baselineBugs.tab6, baselineBugs.tab6[order(Bacteria),])
str(baselineBugs.tab6)
```

```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
confintplot(baselineBugs.tab6, y="Difference", x="Comparison", showSignif = TRUE, pvalVar = "p",
            alpha = 0.05, facets = c("Bacteria", "."), xTickLabelAngle=90)
```

Let's restrict pairwise comparisons to those involving the control treatment only

```{r}
baselineBugs.tab5 <- baselineBugs.tab4[,-4][,c(2,1,3:10)]
baselineBugs.tab7 <- baselineBugs.tab5[baselineBugs.tab5$Disease1=="Control",]
dim(baselineBugs.tab7)
```

```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
baseBugs7.lsd <- getLSDsummary(baselineBugs.tab7, lsdVar="LSD", by = "Bacteria1")
baseBugs7.lsd
baseBugs7.list <- makeLSDlist(meansData = bugs.m2df, y = "Mean", x = "State",
                              LSD = baseBugs7.lsd, eqLevelFactors = "Bacteria",
                              lsdVar = "LSD_avg", edgeWidth = 0.1)
meansLSDplot(lsdList = baseBugs7.list, x = "State", y = "Mean", facets = c("Bacteria","."),
             xLabel = "Disease state", yLabel = "log10(Cell count)",
             tickMarkLabelSize = 11, xTickLabelAngle = 90)
```

## Bugs: Mixed model, adjusting for baseline

```{r, fig.height=4.5, fig.width=8, echo=FALSE, fig.align='center'}
#bugs$clogBase <- bugs$logBaseline - mean(bugs$logBaseline)
# -- log-transform response
bugs$logCells <- log10(bugs$Cells + 1)

# fit mixed model
#lowBugs.lme <- lme(logCells ~ Bacteria*State*Time*clogBase, random = ~1|Rat, data = bugs)
lowBugs.lme <- lme(logCells ~ Bacteria*State*Time*logBaseline, random = ~1|Rat, data = bugs)
anova(lowBugs.lme)

# -- get predicted means at logBase = 4.38
lowBugs.pm <- predictmeans(lowBugs.lme, modelterm = "Bacteria:State:Time", covariate = 4.38,
                           pairwise=TRUE, plot = FALSE)
lowBugs.m2df <- means2df(lowBugs.pm)
lowBugs.m2df

# post-hoc tests summary table
lowBugs.tab <- makeSummaryTable(lowBugs.pm)
head(lowBugs.tab)
dim(lowBugs.tab)

dim(lowBugs.tab[lowBugs.tab$p<0.05,])

# keep only pairwise comparisons in which only the levels of one factor differ
bugs.keepRows <- getFixedLevelComparisons(lowBugs.tab$Comparison, sepChar = ":")
lowBugs.tab1 <- lowBugs.tab[bugs.keepRows,]
dim(lowBugs.tab1)
dim(lowBugs.tab1[lowBugs.tab1$p<0.05,])

# break up comparison names
compNames.df <- comparisonNames2df(lowBugs.tab1$Comparison, split.at = ":",
                                   varNames = c("Bacteria", "State", "Time") )
newlowBugs.tab1 <- data.frame(compNames.df, lowBugs.tab1[,-1])

# pairwise comparisons between 4 and 24h within each Bacteria x State combination
newlowBugsTime.keeprows <- whichComparison(compNames.df, contrFactor="Time")
newlowBugs.tab2 <- newlowBugs.tab1[newlowBugsTime.keeprows,]
dim(newlowBugs.tab2)

# -- compute min, max and average LSD by Bacterial strain and disease State
newlowBugs2.lsd <- getLSDsummary(data = newlowBugs.tab2, lsdVar = "LSD",
                                 by = c("Bacteria1", "State1"))

#' # -- create list needed to plot means and LSDs
newlowBugs2.list <- makeLSDlist(meansData = lowBugs.m2df, y = "Mean", x = "Time",
                                LSD = newlowBugs2.lsd, eqLevelFactors = c("Bacteria", "State"),
                                lsdVar = "LSD_avg", edgeWidth = 0.05)

# plot means with LSD bars, facetting by Bacteria and State
meansLSDplot(lsdList = newlowBugs2.list, x = "Time", y = "Mean", facets = c("Bacteria","State"),
             xLabel = "Time (hours)", yLabel = "Predicted mean",
             tickMarkLabelSize = 11, xTickLabelAngle = 90) +
             geom_line(data = newlowBugs2.list[[1]], size = 0.9)

# pairwise comparisons between 4 and 24h within each Bacteria x State combination
newlowBugsState.keeprows <- whichComparison(compNames.df, contrFactor="State")
newlowBugs.tab3 <- newlowBugs.tab1[newlowBugsState.keeprows,]
dim(newlowBugs.tab3)

# -- compute min, max and average LSD by Bacterial strain and Time
newlowBugs3a.lsd <- getLSDsummary(data = newlowBugs.tab3, lsdVar = "LSD", 
                                  by = c("Bacteria1", "Time1"))
newlowBugs3a.lsd

# -- compute min, max and average LSD by Bacterial strain, as not very different by Time
newlowBugs3b.lsd <- getLSDsummary(data = newlowBugs.tab3, lsdVar = "LSD", by = "Bacteria1")
newlowBugs3b.lsd

# average LSD over bacterial strains
newlowBugs3b.list <- makeLSDlist(meansData = lowBugs.m2df, y = "Mean", x = "Time",
                                 LSD = newlowBugs3b.lsd, eqLevelFactors = "Bacteria",
                                 lsdVar = "LSD_avg", edgeWidth = 0.05)

# plot means facetting only by bacterial strain, using different line types for disease states
meansLSDplot(lsdList = newlowBugs3b.list, x = "Time", y = "Mean", facets = c("Bacteria", "."),
             xLabel = "Time (hours)", yLabel = "log10(Cell count)", shape = "State",
             lineType = "State", tickMarkLabelSize = 11, xTickLabelAngle = 90,
             xStripTextSize = 10, legendKeyWidth = 1.2)

# pairwise comparisons between Bacterial strains within States
newlowBugsBacteria.keeprows <- whichComparison(compNames.df, contrFactor="Bacteria")
newlowBugs.tab4 <- newlowBugs.tab1[newlowBugsBacteria.keeprows,]
names(newlowBugs.tab4)
newlowBugs.tab4 <- transform(newlowBugs.tab4, 
                             State1 = factor(State1, levels=c("Control", "HS", "AP", "DM")))
dim(newlowBugs.tab4)
with(newlowBugs.tab4, newlowBugs.tab4[order(State1, Bacteria1),])

# -- compute min, max and average LSD by Bacterial strain and Time
newlowBugs4a.lsd <- getLSDsummary(data = newlowBugs.tab4, lsdVar = "LSD", 
                                 by = c("State1", "Time1"))
newlowBugs4a.lsd

# -- compute min, max and average LSD by Bacterial strain, as not very different by Time
newlowBugs4b.lsd <- getLSDsummary(data = newlowBugs.tab4, lsdVar = "LSD", by = "State1")
newlowBugs4b.lsd

# average LSD over bacterial strains
newlowBugs4.list <- makeLSDlist(meansData = lowBugs.m2df, y = "Mean", x = "Time",
                                LSD = newlowBugs4b.lsd, eqLevelFactors = "State",
                                lsdVar = "LSD_avg", edgeWidth = 0.05)
newlowBugs4.list

# plot means facetting only by bacterial strain, using different line types for disease states
meansLSDplot(lsdList = newlowBugs4.list, x = "Time", y = "Mean", facets = c("State", "."),
             xLabel = "Time (hours)", yLabel = "log10(Cell count)", shape = "Bacteria",
             lineType = "Bacteria", tickMarkLabelSize = 11, xTickLabelAngle = 90,
             xStripTextSize = 10, legendKeyWidth = 1.2)

newlowBugs.tab4a <- newlowBugs.tab4[, c(2,3,1,4,7:13)]
with(newlowBugs.tab4a, newlowBugs.tab4a[order(State1, Time1),])
```

```{r echo=FALSE, eval=FALSE, include=FALSE}
ggplot(mapping = aes(y=Mean, x=Time, group=Bacteria)) +
  geom_point(data = lowBugs.m2df, aes(shape=Bacteria)) +
  geom_line(data = lowBugs.m2df, aes(linetype=Bacteria)) +
  facet_grid(.~State) +
  geom_hline(yintercept=4.38, linetype="dashed", colour="red") +
  theme_bw()



# let's get predicted means at average value of baseline covariate
lowBugs.AvgBaseline.pm <- predictmeans(lowBugs.lme, modelterm = "Bacteria:State:Time", 
                                       pairwise=TRUE, plot = FALSE)
lowBugs.AvgBaseline.m2df <- means2df(lowBugs.AvgBaseline.pm)
lowBugs.AvgBaseline.m2df

ggplot(mapping = aes(y=Mean, x=Time, group=Bacteria)) +
  geom_point(data = lowBugs.AvgBaseline.m2df, aes(shape=Bacteria)) +
  geom_line(data = lowBugs.AvgBaseline.m2df, aes(linetype=Bacteria)) +
  facet_grid(.~State) +
  geom_hline(yintercept=4.272, linetype="dashed", colour="red") +
  theme_bw()


lowBugs.AvgBaseline.pm <- predictmeans(lowBugs.lme, modelterm = "Bacteria:State:Time", 
                                       covariate=4.45, pairwise=TRUE, plot = FALSE)
lowBugs.AvgBaseline.m2df <- means2df(lowBugs.AvgBaseline.pm)
ggplot(mapping = aes(y=Mean, x=Time, group=Bacteria)) +
  geom_point(data = lowBugs.AvgBaseline.m2df, aes(shape=Bacteria)) +
  geom_line(data = lowBugs.AvgBaseline.m2df, aes(linetype=Bacteria)) +
  facet_grid(.~State) +
  geom_hline(yintercept=4.45, linetype="dashed", colour="red") +
  theme_bw()

## replicate students' analysis for low baseline time=4
## 

bugslow4 <- subset(bugs[,1:6], subset = Time == 4)
bugs$Rat <- factor(bugs$Rat)
str(bugslow4)
bugslow4$Ratio <- with(bugslow4, Cells/Baseline)
bugslow4$logRatio <- log10(bugslow4$Ratio)
with(bugslow4, tapply(log10(Baseline), list(Bacteria, State), mean))
with(bugslow4, tapply(log10(Baseline), Bacteria, mean))

bugslow24 <- subset(bugs[,1:6], subset = Time == 24)
bugslow24$Cells[bugslow24$Cells==0] <- 67
bugslow24$Ratio <- with(bugslow24, Cells/Baseline)
bugslow24$logRatio <- log10(bugslow24$Ratio)
with(bugslow24, tapply(logRatio, list(Bacteria, State), mean))
with(bugslow24, tapply(logRatio, Bacteria, mean))

bugs4low.lme <- lme(logRatio ~ Bacteria*State, random = ~1|Rat, 
                    data = bugslow4)
anova(bugs4low.lme)

summary(aov(logRatio ~ Bacteria*State + Error(Rat), data = bugslow4))
model.tables(aov(logRatio ~ Bacteria*State + Error(Rat), data = bugslow4))
summary(aov(Ratio ~ Bacteria*State + Error(Rat), data = bugslow4))

# -- get predicted means at logBase = 4.38
bugs4low.pm <- predictmeans(bugs4low.lme, modelterm = "Bacteria:State",
                            pairwise=TRUE, plot = FALSE)
bugs4low.m2df <- means2df(bugs4low.pm)
ggplot(mapping = aes(y=Mean, x=State, group=Bacteria)) +
  geom_point(data = bugs4low.m2df, aes(shape=Bacteria)) +
  geom_hline(yintercept=0, linetype="dashed", colour="red") +
  theme_bw()


bugs4low.lme <- lme(logRatio ~ Bacteria*State, random = ~1|Rat, data = bugslow4)
anova(bugs4low.lme)

# -- get predicted means at logBase = 4.38
bugs4low.pm <- predictmeans(bugs4low.lm, modelterm = "Bacteria:State",
                            pairwise=TRUE, plot = FALSE)
bugs4low.m2df <- means2df(bugs4low.pm)
ggplot(mapping = aes(y=Mean, x=State, group=Bacteria)) +
  geom_point(data = bugs4low.m2df, aes(shape=Bacteria)) +
  geom_hline(yintercept=0, linetype="dashed", colour="red") +
  theme_bw()
```

I think I'd like to add a `digits` arg to `makeLSDsummary`.

```{r}
#bugslsd.df <- getLSDsummary(baselineBugs.tab4, lsdVar = "LSD", by = "Bacteria1")
```

```{r}
#makeLSDlist(data = bugs.mse, y = "Mean", x = "State", LSD = )
```

## Other stuff...

In addition to the `fruitfly` and `bugs` data, three simulated datasets (although based on real experiments) are included in `meantable`. These are `crdData`, from a completely randomised design (CRD), `rcbdData`, from a randomised complete block design (RCBD), and `splitBlockData`, from a split-block design (SBD). These have been retained in the package as, some of the functions which now form part of `meantable` were originally developed for use by students in a post-graduate course I teach to biology students. These small datasets were useful instructional tools for first introducing these students to the analysis of CRDs, RCBDs and SBDs.

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))


## References

Gilmour, AR, Gogel, BJ, Cullis, BR, Welham, SJ and Thompson, R (2002) *ASReml User Guide Release 1.0*. VSN International, 5 The Waterhouse, Waterhouse St, Hemel Hempstead, HP1 1ES, UK.

Hanley, JA & Shapiro, SH (1994) Sexual activity and the lifespan of male fruitflies: A Dataset that gets attention, *Journal of Statistics Education*, **2**.

Partridge, L & Farquhar, M (1981) Sexual Activity and the Lifespan of Male Fruitflies, *Nature*, **294**, 580--581.
