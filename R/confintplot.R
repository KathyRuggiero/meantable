#' A ggplot2 wrapper function for generating plots with confidence interval error bars
#'
#' This function generates plots of predicted values (e.g. means, differences between means, etc)
#' with their \eqn{100(1 - \alpha)}\% confidence intervals, where \eqn{\alpha} denotes the level
#' of significance.
#'
#' @param data a dataframe, assumed to be generated by \link{makeSummaryTable}.
#' @param y name of column in \code{data} containing predicted values, usually predicted means
#' or pairwise differences between predicted means.
#' @param x name of variable or factor in \code{data} to be plotted on x-axis.
#' @param pointSize size of plotting character for predicted values.
#' @param showSignif logical (default \code{FALSE}). Controls appearance of plotting characters
#' used for predicted values in \code{y}. If \code{TRUE}, a value must be supplied to
#' \code{alpha} argument and, in this case, a filled circle is drawn for predicted values with a
#' corresponding p-value less than \code{alpha} and an open circle otherwise.
#' @param pvalVar character string giving column name in \code{data} containing p-values
#' @param legendShapeSize size of plotting characters in legend
#' @param legendTextSize font size of legend text
#' @param legendTitle character string, used in title of legend
#' @param zeroline logical (default \code{TRUE}), draws a dashed horizontal line on the plot at
#' \code{y = 0}
#' @param se name of column in \code{data} containing the standard errors of the predicted values
#' provided to \code{y}. A value must be supplied when \code{data} does not include an LSD column.
#' @param df degrees of freedom with which the standard error (see \code{se}) was estimated.
#' A value must be supplied when \code{data} does not include an LSD column.
#' @param alpha level of significance needed to calculate confidence limits. A value must be
#' supplied when \code{data} does not include an LSD column.
#' @param facets character vector of factor names whose levels define a matrix of row and/or column
#' panels in the plot. This vector must be of length 2. Thus, if only one facet factor is needed,
#' fill the vector with the character string \code{"."} (see Examples below). The order of the
#' factor names, one of which may be the character string \code{"."}, determine whether the levels
#' are displayed in rows or columns, with first element (factor name) corresponding to row panels
#' and the second to column panels.
#' @param yLabel y-axis label (character string)
#' @param xLabel x-axis label (character string)
#' @param axisLabelSize font size of x- and y-axis labels. Currently, these cannot be set
#' independently of one another.
#' @param tickMarkLabelSize font size of x- and y-axis tick mark labels. Currently, these cannot be
#' set independently of one another.
#' @param xTickLabelAngle angle (0, 45 or 90; default 0) of x-axis tick labels
#' @param xStripTextSize x strip text size in pts
#' @param yStripTextSize y strip text size in pts
#' @return Generates one- (default) and two-way boxplots. A one-way boxplot is generated when
#' \code{facets} are not supplied (default). A two-way boxplot is generated when \code{facets}
#' are supplied.
#' @return Plot aesthetics, themes, etc. may be saved in an R object so that other
#' layers may be added.
#' @author Katya Ruggiero
#' @details This function is a wrapper to generate side-by-side boxplots for either a single factor
#' or a pair of factors.
#' @seealso \code{\link[ggplot2]{ggplot}} \code{\link[ggplot2]{geom_point}}
#' @seealso \code{\link[ggplot2]{geom_errorbar}} \code{\link[ggplot2]{aes_string}}
#' @seealso \code{\link[ggplot2]{facet_wrap}}
#' @export
#' @importFrom ggplot2 aes_string element_blank element_text facet_grid
#'                     geom_errorbar geom_hline geom_point ggplot
#'                     guide_legend guides scale_fill_manual theme theme_bw
#'                     xlab ylab
#' @importFrom stats qt relevel reformulate
#' @examples
#' library(ggplot2)
#' # Means with 95% CI error bars
#' data(crdData)
#' crd.lm <- lm(logAUC ~ Surgery, data = crdData)
#' crd.pm <- predictmeans(crd.lm, modelterm = "Surgery", pairwise = TRUE, plot=FALSE)
#' crd.tab <- makeSummaryTable(crd.pm)
#' confintplot(data=crd.tab, y="Difference", x="Comparison")
#'
#' # use open and closed circles for p-values less than 0.05
#' confintplot(data=crd.tab, y="Difference", x="Comparison",
#'             showSignif=TRUE, pvalVar="p", alpha = 0.05)
#'
#' # control legend plotting character (shape) and text sizes
#' confintplot(data=crd.tab, y="Difference", x="Comparison",
#'             showSignif=TRUE, pvalVar="p", alpha = 0.05,
#'             legendShapeSize = 5, legendTextSize = 14)



confintplot <- function(data, y, x, pointSize=3.5, showSignif=FALSE, pvalVar,
                        legendShapeSize=3, legendTextSize = 10, legendTitle,
                        zeroline=TRUE, se, df, alpha, facets, xLabel, yLabel,
                        axisLabelSize=14, tickMarkLabelSize=12, xTickLabelAngle = 0,
                        xStripTextSize = 12, yStripTextSize = 12)
{

  if(!(missing(se) & missing(df))) {

    if(missing(alpha)) stop("Level of significance must be supplied to arg `alpha`!",
                            call. = FALSE)
    tval <- qt(1-alpha/2, df)
    lsd <- tval * data[[se]]
    data$lwr <- data[[y]]-lsd
    data$upr <- data[[y]]+lsd

  }
  p <- ggplot() +
    geom_errorbar(data = data,
                  mapping = aes_string(x = x, ymin = "lwr", ymax = "upr"),
                  width=0.2, size=0.9)
  p <- if(showSignif){

    if(missing(alpha))   stop("Level of significance must be supplied to arg `alpha`!",
                            call. = FALSE)
    if(missing(pvalVar)) stop("p-value column name in data must be supplied to arg `pvalVar`!",
                            call. = FALSE)
    data[[pvalVar]] <- factor(ifelse(data[[pvalVar]] < alpha, paste0("p < ", alpha) , "ns"))
    data[[pvalVar]] <- relevel(data[[pvalVar]], ref = paste0("p < ", alpha))
    p + geom_point(data, mapping = aes_string(x = x, y = y, fill = pvalVar),
                   size=pointSize, shape=21, stroke=1.5) +
      scale_fill_manual(values=c("white", "black"))
  }
  else p + geom_point(data, mapping = aes_string(x = x, y = y),
                      size=pointSize, shape=19, stroke=1.5)
  p <- p + theme_bw() +
    theme(axis.title = element_text(size = axisLabelSize),
          axis.text = element_text(size = tickMarkLabelSize),
          legend.text=element_text(size = legendTextSize),
          strip.text.x = element_text(size = xStripTextSize),
          strip.text.y = element_text(size = yStripTextSize))
  p <- p + guides(fill = guide_legend(override.aes = list(size = legendShapeSize)))
  p <- if(!missing(legendTitle)) p + theme(legend.title = legendTitle)
       else                      p + theme(legend.title = element_blank())
  if(xTickLabelAngle != 0){

    p <- if(xTickLabelAngle == 45)
      p + theme(axis.text.x = element_text(angle=xTickLabelAngle, hjust=1, vjust=1))
    else if(xTickLabelAngle == 90)
      p + theme(axis.text.x = element_text(angle=xTickLabelAngle, hjust=1, vjust=0.5))
  }
  if(!missing(xLabel)) p <- p + xlab(xLabel)
  if(!missing(yLabel)) p <- p + ylab(yLabel)
  if(zeroline) p <- p + geom_hline(yintercept=0, linetype="dashed", size=0.9, colour="black")
  if (!missing(facets)){

    if(length(facets) > 2) stop("Currently only 2 facets allowed!", call.=FALSE)
    p <- p + facet_grid(reformulate(facets[1], facets[2]), drop = TRUE, scales="free_x")

  }

  p

}

