#' Converts a flat table of predicted means to a dataframe.
#'
#' This function converts the first two objects in the list generated by the `predictmeans()`
#' function into a dataframe. The first element of this list, \code{`Predict Means`}, containing
#' the model predicted means is of class \code{ftable}, while the second, \code{`Standard Error of
#' Means`}, is either of class \code{numeric}, e.g. equi-replicate designs in which the standard
#' error of the mean is common across all predicted means, or of class \code{ftable}, e.g. unbalanced
#' designs or weighted least squares analysis.

#' @param data a list in which the first element is a flat table (i.e. class \code{ftable}) of
#' predicted means and the second element is either \code{numeric} or \code{ftable} and contains the
#' standard error(s) of the means.
#' @param se logical (default \code{TRUE}), includes standard errors of means in dataframe.
#' @param digits integer indicating the number of decimal places (\code{round}) to be used.
#' @return A dataframe comprising a column for each factor in the model term supplied to the
#' \code{modelterm} argument in the \link{predictmeans} function, and columns for the model
#' predicted means and their standard errors.
#' @author Katya Ruggiero
#' @details This function assumes that the list supplied to the \code{data} argument was generated
#' by the \link{predictmeans} function in the \code{predictmeans} package.
#' @export
#' @importFrom nlme lme
#' @importFrom lme4 lmer
#' @importFrom reshape melt
#' @importFrom predictmeans predictmeans
#' @examples
#' data(fruitfly)
#' # fit model for factorial experiment with added control
#' newfruitfly <- toFactor(fruitfly, variables = c("ID", "Partners", "Type"))
#' newfruitfly$Control <- factor(ifelse(newfruitfly$Type==0, "Yes", "No"))
#' fruitfly.lm <- lm(Longevity ~ Control/(Partners*Type), data=newfruitfly)
#' fruitfly.pm <- predictmeans(fruitfly.lm, modelterm = "Control:Partners:Type", pairwise = TRUE,
#' plot = FALSE)
#' means2df(fruitfly.pm, digits=2)
#'
#' # weighted least squares analysis of baseline inoculation concentration
#' data(bugs)
#' bugs$logBaseline <- log(bugs$Baseline + 1)
#' var.mat <- with(bugs, tapply(logBaseline, list(State, Bacteria), var))
#' var.df <- melt(var.mat)
#' names(var.df) <- c("State", "Bacteria", "Var")
#' newbugs <- merge(bugs, var.df)
#' newbugs$Weight <- 1/newbugs$Var
#' # WLS two-way anova
#' baselineBugs.lm <- lm(logBaseline ~ State*Bacteria, data = newbugs, weights = Weight)
#' # Predicted means
#' baselineBugs.pm <- predictmeans(baselineBugs.lm, modelterm = "State:Bacteria", pairwise=TRUE,
#' plot = FALSE)
#' means2df(baselineBugs.pm)

means2df <- function(data, se=TRUE, digits){

  means <- as.data.frame(data[[1]])
  nCol <- ncol(means)
  names(means)[nCol] <- "Mean"
  sems <-
    if(any(is.element(class(data[[2]]), c("ftable", "table", "xtabs")))) as.data.frame(data[[2]])[,nCol]
    else if(class(data[[2]]) == "numeric") rep(data[[2]], nrow(means))
  pm.df <- if(se) data.frame(means, "s.e." = sems)
  else   means
  if(!missing(digits)) pm.df[,-(1:(nCol-1))] <- round(pm.df[,-(1:(nCol-1))], digits = digits)

  pm.df[!is.na(pm.df$Mean),]

}
