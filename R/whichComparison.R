#' Generates a logical vector for subsetting from a table of pairwise comparisons of treatments
#'
#' The vector of logicals generated by this function yields a TRUE value for each pairwise
#' comparison of factorial treatment combinations in which all, but one, of the matching factors
#' in the two treatment combinations have the same value (level). This function requires a
#' dataframe in which the character string for each factorial treatment combination has been
#' decoupled into its original components, i.e. a column per factor making up each factorial
#' treatment combination. See \code{Details} for more information.
#'
#' @param data a dataframe containing 2n columns, where n is the number of factors contributing to
#' a factorial treatment combination. The labels in the first n columns contain the levels
#' contributing
#' to the factorial treatment combination of the first mean in the comparison, while the second n
#' columns contain the levels contribution to the second mean.
#' @param contrFactor name of factor with different values (levels) in the two factorial treatment
#' combinations being contrasted.
#'
#' @return a vector of logicals which has as many elements as there are rows in \code{data}.
#'
#' @author Katya Ruggiero
#'
#' @details The dataframe required by the \code{data} argument in this function may
#' be generated by applying the
#' \link{comparisonNames2df} function to the \code{Comparison} column in the dataframe
#' generated by the \link{makeSummaryTable} function available in this package.
#'
#'
#' @seealso \code{\link[meantable]{makeComparisonNames}}
#' @seealso \code{\link[meantable]{makeSummaryTable}}
#' @seealso \code{\link[meantable]{comparisonNames2df}}
#' @export
#' @examples
#' library(predictmeans)
#' library(nlme)
#' Oats$nitro <- factor(Oats$nitro)
#' fm <- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
#'
#' # library(lme4)
#' # fm <- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
#'
#' pm <- predictmeans(fm, "nitro:Variety", pairwise=TRUE, plot=FALSE)
#' oats.tab <- makeSummaryTable(pm)
#' compNames.df <- comparisonNames2df(oats.tab[,1], split.at = ":", varNames = c("nitro", "Variety") )
#' newoats.tab <- data.frame(compNames.df, oats.tab[,-1])
#'
#' # pairwise comparisons between nitro levels within varieties
#' keeprows <- whichComparison(compNames.df, contrFactor="nitro")
#' newoats.tab[keeprows,]

whichComparison <- function(data, contrFactor){

  nCol <- ncol(data)
  nVar <- nCol/2    # number of factors in factorial treatment combination

  # find columns corresponding to contrFactor whose levels we want to be different
  factorCols <- grep(paste0("^(", contrFactor, ")"), names(data))

  # initialise matrix with as many columns as there are factors in factorial trt combination
  keep.mat <- matrix(NA, nrow=nrow(data), ncol=nVar)
  # set to TRUE all rows for which contrFactor has unequal levels
  keep.mat[,1] <- data[,factorCols[1]] != data[,factorCols[2]]

  # for all other factors, set to TRUE all rows for which the given contrFactor has same level
  colNumber.mat <- matrix(1:nCol, ncol=2)
  keepRows <- !apply(colNumber.mat, 1, function(x) identical(factorCols, x))
  colNumber.mat <- colNumber.mat[keepRows,,drop=FALSE]
  for(i in 1:nrow(colNumber.mat))
    keep.mat[,i+1] <- data[,colNumber.mat[i,1]] == data[,colNumber.mat[i,2]]

  # now find rows which satisfy the above conditions across all factors
  keep <- apply(keep.mat, 1, all)

  return(keep)

}

