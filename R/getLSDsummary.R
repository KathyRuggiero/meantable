#' Computes minimum, average and maximum least significant difference (LSD) of selected
#' pairwise treatment comparisons
#'
#' This function uses the LSDs contained in the summary table of pairwise comparisons of means,
#' generated by \link{makeSummaryTable}, to compute the minimum, average and maximum LSD for
#' pairwise comparisons of means. See \code{Details}.
#'
#' @param data dataframe; see \code{Details} below for requirements and how to generate.
#' @param lsdVar character string of column name in \code{data} containing LSDs.
#' @param by character vector of factor (column) names in \code{data}. The
#' minimum, mean and maximum LSD will be computed across all values within each level, or
#' combination of levels, defined by the factor(s) supplied to this argument.
#' @param alphaName remove trailing digits ('1' and '2' only) at the end of \code{by} names.
#' Default is \code{TRUE}. See \code{Details} for more information.
#' @return A dataframe comprising a column for each factor in \code{by} and a column for the
#' minimum (min), average (avg) and maximum (max)  LSD for each factorial treatment combination given
#' by the levels of the factors in \code{by}.
#' @author Katya Ruggiero
#' @details The dataframe required by the \code{data} argument in this function may be generated
#' by the \link{makeSummaryTable} function. If this dataframe is used, the \code{Comparison}
#' column must be replaced with the dataframe generated by \link{comparisonNames2df}
#' function, as shown in the examples below. This results in the single \code{Comparison} column
#' being replaced by \eqn{2 \times n} columns, with these new columns having names ending with either
#' 1 or 2 (see Details section of \link{comparisonNames2df}). The \code{alphaName = TRUE}
#' argument in the current function drops these trailing digits when naming columns of the
#' dataframes generated by the current function. This is because the current function is called by
#' \link{makeLSDlist}, which requires that these column names be identical to those provided
#' to the \code{by} arg. Thus, default \code{alphaName = TRUE} ensures the matching of these
#' names.
#'
#' @export
#' @importFrom stats as.formula
#' @importFrom reshape melt cast
#' @examples
#' library(nlme)
#' library(predictmeans)
#' Oats$nitro <- factor(Oats$nitro)
#' fm <- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
#' # library(lme4)
#' # fm <- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
#' pm <- predictmeans(fm, "nitro:Variety", pairwise=TRUE, plot=FALSE)
#' pm.tab <- makeSummaryTable(pm)
#' compNames.df <- comparisonNames2df(pm.tab$Comparison, split.at=":",
#'                                   varNames=c("nitro", "Variety"))
#' # keep rows in which Variety1 = Variety2
#' keepRows <- whichComparison(compNames.df, contrFactor="nitro")
#' newpm.tab <- data.frame(compNames.df, pm.tab[,-1])[keepRows,]
#' getLSDsummary(newpm.tab, lsdVar = "LSD", by = "Variety1")

getLSDsummary <- function (data, lsdVar, by, alphaName=TRUE)
{

  lsdSummary <- function(y) c(min = min(y, na.rm = TRUE),
                              avg = mean(y, na.rm = TRUE),
                              max = max(y, na.rm = TRUE))

  molten.df <- melt(data, id.vars = by, measure.vars = lsdVar)
  castingFormula <- as.formula(paste(paste(by, collapse = " + "), "~ variable"))
  lsdsummary.df <- cast(molten.df, castingFormula, fun.aggregate = lsdSummary)
  if(alphaName){

    index <- match(by, names(lsdsummary.df))
    by <- gsub("[1-2]$", "", by)

  }
  names(lsdsummary.df)[index] <- by

  return(lsdsummary.df)

}
